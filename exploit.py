from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException
from hwilib import commands
from hwilib.devices import coldcard, ledger, trezor
from hwilib.serializations import PSBT

# Setup rpc client
rpc_user = "u"
rpc_password = "p"
rpc_wallet_name = "segwit-bug"
default_rpc = AuthServiceProxy("http://%s:%s@127.0.0.1:18443/wallet/"%(rpc_user, rpc_password))
wallet_rpc = AuthServiceProxy("http://%s:%s@127.0.0.1:18443/wallet/%s"%(rpc_user, rpc_password, rpc_wallet_name))

# constants
sequence = 0xffffffff

def get_hwi_client():
    '''create hwi client for plugged-in hardware wallet'''
    # list devices
    devices = commands.enumerate()

    # make sure there is only one
    assert len(devices) == 1, "One hardware wallet must be plugged in"

    # make sure it's unlocked
    device = devices[0]
    fingerprint = device.get("fingerprint")
    assert fingerprint is not None, f"Your ${device.type} is locked"

    # return client that can address this device
    if device['type'] == 'ledger':
        client = ledger.LedgerClient(device['path'])
    elif device['type'] == 'coldcard':
        client = coldcard.ColdcardClient(device['path'])
    elif device['type'] == 'trezor':
        client = trezor.TrezorClient(device['path'])
    else:
        raise Exception(f"Couldn't create client for you \"${device.type}\" device")
    
    # set HWI to testnet
    client.is_testnet = True

    return client

def prepare():
    '''create watch-only bitcoin core wallet to use with trezor'''
    # generate address on default rpc wallet
    default_address = default_rpc.getnewaddress()
    print(default_address)

    # generate 150 block to this address (so we have some coins to play with)
    default_rpc.generatetoaddress(150, default_address)
    
    # create or load watch-only wallet to use with our trezor
    ensure_watchonly_wallet()

    return default_address

def load_wallet():
    try:
        default_rpc.loadwallet(rpc_wallet_name)
        return True
    except JSONRPCException as e:
        if e.message == f"Wallet {rpc_wallet_name} not found.":
            return False
        else:
            raise(e)  # propogate any other error

def ensure_watchonly_wallet():
    # check if this rpc wallet is already loaded
    loaded_rpc_wallets = default_rpc.listwallets()
    if rpc_wallet_name in loaded_rpc_wallets:
        print("Wallet already loaded")
        return

    # attempt to load this wallet in case it already exists
    if load_wallet():
        print("Wallet loaded")
        return

    # wallet doesn't exist yet, create it
    create_wallet_response = default_rpc.createwallet(rpc_wallet_name, True)
    if create_wallet_response["warning"] != "":
        raise Exception("Failed to create watch-only wallet")
    else:
        print("Wallet created")

def derive_address(descriptor, index):
    result = wallet_rpc.deriveaddresses(descriptor, [index, index])
    return result[0]

def get_p2wpkh_descriptor():
    hwi_client = get_hwi_client()
    all_descriptors = commands.getdescriptors(hwi_client)
    receive_descriptors = all_descriptors["receive"]
    receive_p2wpkh_descriptor_index = 2
    receive_p2wpkh_descriptor = receive_descriptors[receive_p2wpkh_descriptor_index]
    return receive_p2wpkh_descriptor


def import_addresses(descriptor):
    commands = [
        {
            "desc": descriptor,
            "watchonly": True,
            "range": [0, 100],
            "timestamp": "now"
        }
    ]
    result = wallet_rpc.importmulti(commands)
    print(result)

def find_unspent(address, amount):
    for unspent in wallet_rpc.listunspent():
        if unspent["address"] == address and unspent["amount"] == amount:
            return unspent
    raise Exception(f"Couldn't find unspent for address={address} and amount={amount}")

def create_psbt(descriptor, send_address, change_address, amount):
    outputs = [
        {
            send_address: amount
        }
    ]
    raw_psbt = wallet_rpc.walletcreatefundedpsbt(
        # let Bitcoin Core choose inputs
        [],
        # Outputs
        outputs,
        # Locktime
        0, 
        {
            # Include watch-only outputs
            "includeWatching": True,
            # Provide change address b/c Core can't generate it
            "changeAddress": change_address,
            },
        # Include BIP32 derivation paths in the PSBT
        True,
    )['psbt']
    return raw_psbt

def main():
    default_address = prepare()

    # get p2wpkh descriptor from our hww
    descriptor = get_p2wpkh_descriptor()
    print(descriptor)

    # export some addresses from trezor to bitcoin core
    import_addresses(descriptor)

    # create and fund addresses with amounts matching trezor write-up
    addr_15 = derive_address(descriptor, 0)
    addr_20 = derive_address(descriptor, 1)
    print(addr_15)

    # initial balances
    print("initial balances", wallet_rpc.getbalances()['watchonly']['trusted'])

    # fund addresses
    send_res = default_rpc.sendtoaddress(addr_15, 15)
    default_rpc.sendtoaddress(addr_20, 20)
    default_rpc.generatetoaddress(1, default_address)

    # final balances
    print("final balances", wallet_rpc.getbalances()['watchonly']['trusted'])

    # find utxos
    unspent_15 = find_unspent(addr_15, 15)
    unspent_20 = find_unspent(addr_20, 20)
    print(unspent_15, unspent_20)

    # create psbt
    change_address = derive_address(descriptor, 2)
    send_address = default_address
    amount = 10
    psbt = create_psbt(descriptor, send_address, change_address, amount)
    print(psbt)


main()
